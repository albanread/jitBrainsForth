# Loop Constructs in Forth

Forth is a stack-based programming language, and its loop constructs are built to fit into its unique style. Below are the common loop constructs in Forth:

### 1. **BEGIN ... UNTIL**

This loop continues until a specified condition is true.

```forth
: example-loop
  BEGIN
    do-something   \ perform some action
    condition?   \ check condition
  UNTIL ;
```

### 2. **BEGIN ... WHILE ... REPEAT**

This is a conditional loop that continues to execute as long as a condition is true.

```forth
: example-loop
  BEGIN
    do-something   \ perform some action
    condition?   \ check condition
  WHILE
    more-actions   \ perform more actions
  REPEAT ;
```

### 3. **DO ... LOOP**

This is a counted loop that repeats a specified number of times.

```forth
: example-loop
  10 0 DO   \ loop from 0 to 9 (10 times)
    i .   \ print the loop index
  LOOP ;
```

### 4. **DO ... +LOOP**

Similar to `DO ... LOOP`, but allows for a variable step size.

```forth
: example-loop
  10 0 DO   \ loop from 0 to 9 (10 times)
    i .   \ print the loop index
    2 +LOOP ;   \ increment the loop index by 2 each time
```

### Explanation of Terms:

- **`: example-loop ... ;`**: This defines a new word (function) named `example-loop`.
- **`BEGIN ... UNTIL`**: Executes the code between `BEGIN` and `UNTIL` until the condition after `UNTIL` becomes true.
- **`BEGIN ... WHILE ... REPEAT`**: Executes the code between `BEGIN` and `WHILE` while the condition after `WHILE` is true. If the condition is false, it jumps to after `REPEAT`.
- **`DO ... LOOP`**: Initializes a loop from a starting value to an ending value, repeating the code between `DO` and `LOOP`.
- **`DO ... +LOOP`**: Similar to `DO ... LOOP`, but the loop index can be incremented by a step size other than 1.
- **`i`**: The loop index within the `DO ... LOOP` constructs.

These are the basic loop constructs used in Forth to handle iterative tasks. Each construct is versatile and can be used depending on the specific requirement of the program logic.

## Implementation Details

In the ongoing development, the loop constructs are implemented using ASMJIT generator functions. 
These constructs are immediate words, meaning that during the compilation of a colon definition, 
these words execute and construct the loops by generating labels and branch instructions in the machine code.

ASMJIT is a complete JIT and AOT assembler for x86/x64 architectures. It can generate machine code for a variety of purposes, including JIT compilers, runtime code generators, and more.
In this case a C++ program is using ASMJIT to act like a macro assembler and generate the machine code for the Forth interpreter.

## How Loops are Implemented


When ASMJIT runs it needs to generate labels, that it later binds.

The `BEGIN ... UNTIL` construct is implemented by generating a label at the beginning of the loop and a conditional jump to the label at the end of the loop.

The `BEGIN ... WHILE ... REPEAT` construct is implemented by generating a label at the beginning of the loop, a conditional jump to the end of the loop, and a label at the end of the loop.

The `DO ... LOOP` construct is implemented by generating a label at the beginning of the loop, a conditional jump to the end of the loop, and a label at the end of the loop. The loop index is stored in a register and incremented by 1 each time.

The `DO ... +LOOP` construct is implemented similarly to `DO ... LOOP`, but the loop index is incremented by a specified step size each time.

There is also an EXIT word that can be used to exit a loop early.

The EXIT word jumps to the end of the loop, skipping the remaining iterations.
This means that the loop construct must generate a label at the end of the loop, and the EXIT word must jump to that label.

Loops may be nested, but they will not overlap.


### Other Constructs Using Labels

Several other Forth features also require labels and branch instructions, including:

1. **Conditional Execution:**
    - **IF ... ELSE ... THEN**: Uses labels to manage branching based on conditions.
    - **CASE ... OF ... ENDOF ... ENDCASE**: Case statements use labels for handling different conditions.

2. **Early Exits:**
    - **LEAVE**: Requires labels to facilitate early exits from loops, jumping to the loop's end.

3. **Recursion and Function Calls:**
    - **RECURSE**: Uses labels for managing entry and exit points 
    - in the generated code during recursive calls.


These structures may be nested and should not overlap.

## Conclusion

During compilation a stack of labels is maintained, and the loop constructs push and pop labels from this stack as needed.
The labels are generated by ASMJIT and bound to the appropriate locations in the machine code.

The stack of labels is also used to check for errors, such as mismatched loop constructs or early exits that are not within a loop.

To do this labels are tagged with additonal information, such as the type of loop construct they belong to, and the nesting level of the loop.

In c++ the struct for a label might look like this:

```cpp

#include <stack>
#include <vector>

// Define LabelType and Label struct 
enum class LabelType {
    LOOP_BEGIN,      // Label for the beginning of a loop
    LOOP_END,        // Label for the end of a loop
    CONDITIONAL_IF,  // Label for the start of an IF branch
    CONDITIONAL_ELSE,// Label for the ELSE branch
    CONDITIONAL_END, // Label for the end of an IF-THEN construct
    CASE_START,      // Label for the start of a CASE statement
    CASE_END,        // Label for the end of a CASE statement
    FUNCTION_ENTRY,  // Label for function entry (e.g., recursion)
    FUNCTION_EXIT    // Label for function exit
};

struct LabelData {
    int id;
};
// Define the Label structure to include ASMJIT labels and related data
struct Label {
    LabelType type;
    int nestingLevel;
    LabelData data;
    asmjit::Label asmLabel;  // ASMJIT label
};

// Define the Label structure to include ASMJIT labels and related data
struct Label {
    LabelType type;
    int nestingLevel;
    LabelData data;
    asmjit::Label asmLabel;  // ASMJIT label
};

// Define the LabelStack class
class LabelStack {
public:
    // Constructor to initialize with a reference to an ASMJIT assembler
    LabelStack(asmjit::x86::Assembler& assembler) : assembler(assembler) {}

    // Push a new label onto the stack and create an ASMJIT label
    void push(LabelType type, int nestingLevel, LabelData data) {
        asmjit::Label asmLabel = assembler.newLabel();  // Create a new ASMJIT label
        Label label = { type, nestingLevel, data, asmLabel };
        stack.push(label);
    }

    // Pop the top label from the stack
    Label pop() {
        if (!stack.empty()) {
            Label topLabel = stack.top();
            stack.pop();
            return topLabel;
        } else {
            throw std::runtime_error("Attempt to pop from an empty stack");
        }
    }

    // Peek at the top label without removing it
    Label top() const {
        if (!stack.empty()) {
            return stack.top();
        } else {
            throw std::runtime_error("Attempt to peek at an empty stack");
        }
    }

    // Check if the stack is empty
    bool empty() const {
        return stack.empty();
    }

    // Bind the top label to the current code position
    void bindTopLabel() {
        if (!stack.empty()) {
            assembler.bind(stack.top().asmLabel);
        } else {
            throw std::runtime_error("Attempt to bind a label from an empty stack");
        }
    }

    // Syntax checking functions
    void syntaxCheckThen() const {
        if (stack.empty() || stack.top().type != LabelType::IF) {
            throw std::runtime_error("THEN without matching IF");
        }
    }

    void syntaxCheckElse() const {
        if (stack.empty() || stack.top().type != LabelType::IF) {
            throw std::runtime_error("ELSE without matching IF");
        }
    }

    void syntaxCheckAgain() const {
        if (stack.empty() || stack.top().type != LabelType::BEGIN) {
            throw std::runtime_error("AGAIN without matching BEGIN");
        }
    }

    void syntaxCheckUntil() const {
        if (stack.empty() || stack.top().type != LabelType::BEGIN) {
            throw std::runtime_error("UNTIL without matching BEGIN");
        }
    }

private:
    std::stack<Label> stack;  // Stack to maintain labels
    asmjit::x86::Assembler& assembler;  // Reference to ASMJIT assembler
};

// Example usage of the LabelStack with syntax checking
void handleIF(LabelStack& labelStack) {
    labelStack.push(LabelType::IF, labelStack.nestingLevel(), /*appropriate LabelData*/);
    labelStack.bindTopLabel();
}

void handleTHEN(LabelStack& labelStack) {
    labelStack.syntaxCheckThen();  // Syntax check before proceeding
    labelStack.bindTopLabel();     // Bind the label for THEN
    labelStack.pop();              // Pop the IF label from the stack
}

void handleELSE(LabelStack& labelStack) {
    labelStack.syntaxCheckElse();  // Syntax check before proceeding
    // Additional handling for ELSE, e.g., create a new label for the END of ELSE
    labelStack.bindTopLabel();
}

void handleBEGIN(LabelStack& labelStack) {
    labelStack.push(LabelType::BEGIN, labelStack.nestingLevel(), /*appropriate LabelData*/);
    labelStack.bindTopLabel();
}

void handleAGAIN(LabelStack& labelStack) {
    labelStack.syntaxCheckAgain();  // Syntax check before proceeding
    labelStack.bindTopLabel();      // Bind the label for AGAIN
    labelStack.pop();               // Pop the BEGIN label from the stack
}

void handleUNTIL(LabelStack& labelStack) {
    labelStack.syntaxCheckUntil();  // Syntax check before proceeding
    labelStack.bindTopLabel();      // Bind the label for UNTIL
    labelStack.pop();               // Pop the BEGIN label from the stack
}

void handleEXIT(LabelStack& labelStack) {
    labelStack.syntaxCheckExit();  // Syntax check before proceeding
    labelStack.bindTopLabel();      // Bind the label for EXIT
    labelStack.pop();               // Pop the BEGIN label from the stack
}

void handleLEAVE(LabelStack& labelStack) {
    labelStack.syntaxCheckLeave();  // Syntax check before proceeding
    labelStack.bindTopLabel();      // Bind the label for LEAVE
    labelStack.pop();               // Pop the BEGIN label from the stack
}

void handleRECURSE(LabelStack& labelStack) {
    labelStack.syntaxCheckRecurse();  // Syntax check before proceeding
    labelStack.bindTopLabel();      // Bind the label for RECURSE
    labelStack.pop();               // Pop the BEGIN label from the stack
}

```

## During compilation

When a new function definition is created a new Label is created and pushed onto the label stack.
Code to do this might look like this:

```cpp  
    LabelData data = { id };
    labelStack.push(LabelType::FUNCTION_ENTRY, nestingLevel, data);
```

When a loop construct is encountered a new Label is created and pushed onto the label stack.

Code for BEGIN might look like this:

```cpp
    LabelData data = { id };
    labelStack.push(LabelType::LOOP_BEGIN, nestingLevel, data);
```

Code for AGAIN (which jumps back to the beginning of the loop) might look like this:

```cpp
    labelStack.syntaxCheckAgain();  // Syntax check before proceeding
    labelStack.bindTopLabel();      // Bind the label for AGAIN
    labelStack.pop();               // Pop the BEGIN label from the stack
```

When the end of a loop is reached the loop is popped from the stack.

Code for UNTIL might look like this:

```cpp
    labelStack.syntaxCheckUntil();  // Syntax check before proceeding
    labelStack.bindTopLabel();      // Bind the label for UNTIL
    labelStack.pop();               // Pop the BEGIN label from the stack
```
Code for REPEAT might look like this:

```cpp
    labelStack.syntaxCheckRepeat();  // Syntax check before proceeding
    labelStack.bindTopLabel();      // Bind the label for REPEAT
    labelStack.pop();               // Pop the BEGIN label from the stack
```

The code is implemented in the LabelStack class, which maintains a stack of labels and provides methods for pushing, popping, and binding labels. It also includes syntax checking methods to ensure that labels are used correctly.

This approach allows the Forth interpreter to handle loop constructs and other features that require labels and branching instructions in a flexible and efficient manner.

## Summary

Loop constructs in Forth are implemented using labels and branch instructions generated by ASMJIT. The LabelStack class maintains a stack of labels and provides methods for pushing, popping, and binding labels. Syntax checking methods ensure that labels are used correctly and that loop constructs are properly nested and terminated.




















